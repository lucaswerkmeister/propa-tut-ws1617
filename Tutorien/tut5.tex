\documentclass{beamer}
\usepackage{tut}

\def\tuttitle{Lambda-Kalkül, Typprüfung}
\date{2016-11-28/29}

\begin{document}
\normalsize
\normalem

\begin{frame}[plain]
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Church-Zahlen}
  \begin{align*}
    0 &= 0 \\
    1 &= 1 + 0 \\
    2 &= 1 + 1 + 0 \\
    3 &= 1 + 1 + 1 + 0 \\
    \\
    c_0 &= λs.~λz.~z \\
    c_1 &= λs.~λz.~s~z \\
    c_2 &= λs.~λz.~s~s~z \\
    c_3 &= λs.~λz.~s~s~s~z
  \end{align*}
  Die Church-Zahl für $n∈ℕ$ besteht daraus, dass die Nachfolgerfunktion~$s$ $n$~mal auf das Nullelement~$z$ angewendet wird.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Church-Zahlen in Haskell}
  Der Typ einer Church-Zahl in Haskell ist:
  \begin{lstlisting}
    type Church t = (t -> t) -> t -> t
    ----               s        z
  \end{lstlisting}
  Definiere
  \begin{lstlisting}
    int2church :: Integer -> Church t
    church2int :: Church Integer -> Integer
  \end{lstlisting}
  um von und zu gewöhnlichen Zahlen zu konvertieren.
  (\lstinline{church2int} geht ohne Rekursion.)
\end{frame}

\begin{frame}[fragile]
  \frametitle{\lstinline{int2church}}
  \begin{align*}
    c_0 &= λs.~λz.~z \\
    c_n &= λs.~λz.~\underbrace{s~(s~(\ldots~s}_{\text{$n$ mal}}~z))
  \end{align*}
  \begin{lstlisting}
    int2church :: Integer -> Church t
  \end{lstlisting}
  \pause
  \begin{lstlisting}
    int2church 0 = \s z -> z
    int2church n = \s z -> int2church (n-1) s (s z)
    -- oder
    int2church n = \s z -> s (int2church (n-1) s z)
  \end{lstlisting}
\end{frame}

\end{document}
