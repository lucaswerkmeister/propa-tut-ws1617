\documentclass{beamer}
\usepackage{tut}

\def\tuttitle{Lambda-Kalkül, Typprüfung}
\date{2016-11-28/29}

\begin{document}
\normalsize
\normalem

\begin{frame}[plain]
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Church-Zahlen}
  \begin{align*}
    0 &= 0 \\
    1 &= 1 + 0 \\
    2 &= 1 + 1 + 0 \\
    3 &= 1 + 1 + 1 + 0 \\
    \\
    c_0 &= λs.~λz.~z \\
    c_1 &= λs.~λz.~s~z \\
    c_2 &= λs.~λz.~s~s~z \\
    c_3 &= λs.~λz.~s~s~s~z
  \end{align*}
  Die Church-Zahl für $n∈ℕ$ besteht daraus, dass die Nachfolgerfunktion~$s$ $n$~mal auf das Nullelement~$z$ angewendet wird.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Church-Zahlen in Haskell}
  Der Typ einer Church-Zahl in Haskell ist:
  \begin{lstlisting}
    type Church t = (t -> t) -> t -> t
    ----               s        z
  \end{lstlisting}
  Definiere
  \begin{lstlisting}
    int2church :: Integer -> Church t
    church2int :: Church Integer -> Integer
  \end{lstlisting}
  um von und zu gewöhnlichen Zahlen zu konvertieren.
  (\lstinline{church2int} geht ohne Rekursion.)
\end{frame}

\begin{frame}[fragile]
  \frametitle{\lstinline{int2church}}
  \begin{align*}
    c_0 &= λs.~λz.~z \\
    c_n &= λs.~λz.~\underbrace{s~(s~(\ldots~s}_{\text{$n$ mal}}~z))
  \end{align*}
  \begin{lstlisting}
    int2church :: Integer -> Church t
  \end{lstlisting}
  \pause
  \begin{lstlisting}
    int2church 0 = \s z -> z
    int2church n = \s z -> int2church (n-1) s (s z)
    -- oder
    int2church n = \s z -> s (int2church (n-1) s z)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\lstinline{church2int}}
  \begin{lstlisting}
    church2int :: Church Integer -> Integer
  \end{lstlisting}
  \pause
  \begin{lstlisting}
    church2int c = c (1+) 0
  \end{lstlisting}
  Damit ist
  \begin{lstlisting}
    church2int c3
      = (\s z ->  s   ( s   ( s     z)))  (1+)  0
      =          (1+) ((1+) ((1+)   0))
      =           1  +  1  +  1  +  0
      = 3
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Redexe, Auswertungsstrategie}
  Markiere alle Redexe.
  Welcher wird unter Normal(en)reihenfolge, Call-By-Name und Call-By-Value jeweils zuerst reduziert?
  \pause
  \begin{align*}
    t_1 &= (\cul<3->[c1]{λt.}~λf.~f)~\cul<3->[c1]{((\cul<3->[c2]{λy.}~(\cul<3->[c3]{λx.}~x~x)~\cul<3->[c3]{(λx.~x~x)})~\cul<3->[c2]{((\cul<3->[c4]{λx.}~x)~\cul<3->[c4]{(λx.~x)})})}~(λt.~λf.~f)
  \end{align*}
  \pause[4]%
  Normalreihenfolge und Call-By-Name werten \textcolor{c1}{blau} zuerst aus,
  Call-By-Value wertet \textcolor{c4}{rot} zuerst aus.
  \pause
  \begin{align*}
    t_2 &= λy.~(\cul<6->[c1]{λz.}~(\cul<6->[c2]{λx.}~x)~\cul<6->[c2]{(λx.~x)}~z)~\cul<6->[c1]{y}
  \end{align*}
  \pause[7]%
  Normalenreihenfolge wertet \textcolor{c1}{blau} zuerst aus,
  Call-By-Value und Call-By-Name machen nichts
  ($t_2$ ist schon ein Wert).
\end{frame}

\begin{frame}
  \frametitle{Church-Paare}
  Das Paar $(a,b)$ kann im Lambda-Kalkül so dargestellt werden:
  \[λ?f.~?f~a~b\]
  Damit ist der Paar-Konstruktor \vl{pair}:
  \[\vl{pair} = λ?a.~λ?b.~λ?f.~?f~?a~?b\]
  Wie in Haskell sollen Funktionen \vl{fst}, \vl{snd} erstes und zweites Element extrahieren.
  Dabei ist \vl{fst}:
  \[\vl{fst} = λ?p.~?p~(λ?a.~λ?b.~?a)\]
  Definiere \vl{snd}.
  \pause
  \[\vl{snd} = λ?p.~?p~(λ?a.~λ?b.~?b)\]
\end{frame}

\begin{frame}
  \frametitle{Church-Paare}
  Zeige durch Beta-Reduktion mit Call-By-Name:
  \[\vl{fst}~(\vl{pair}~a~b) \betareduce^\ast a\]
  \pause
  \begin{align*}
    \vl{fst}~(\vl{pair}~a~b) &= (λ?p.~?p~(λ?a.~λ?b.~?a))~((λ?a.~λ?b.~λ?f.~?f~?a~?b)~a~b) \\
    \onslide<3->{&\betareduce (λ?a.~λ?b.~λ?f.~?f~?a~?b)~a~b~(λ?a.~λ?b.~?a)} \\
    \onslide<4->{&\betareduce (λ?b.~λ?f.~?f~a~?b)~b~(λ?a.~λ?b.~?a)} \\
    \onslide<5->{&\betareduce (λ?f.~?f~a~b)~(λ?a.~λ?b.~?a)} \\
    \onslide<6->{&\betareduce (λ?a.~λ?b.~?a)~a~b} \\
    \onslide<7->{&\betareduce (λ?b.~a)~b} \\
    \onslide<8->{&\betareduce a}
  \end{align*}
\end{frame}

\begin{frame}
  \frametitle{\vl{next}}
  \vl{next} soll aus Paar $(n,m)$ das Paar $(m, m+1)$ berechnen (alles in Church-Darstellung).
  \pause
  \begin{align*}
    \vl{next} &= λ?p.~\vl{pair}~(\vl{snd}~?p)~(\vl{succ}~(\vl{snd}~?p))
    \intertext{oder:}
    \vl{next} &= λ?p.~(λ?m.~\vl{pair}~?m~(\vl{succ}~?m))~(\vl{snd}~?p)
  \end{align*}
\end{frame}

\begin{frame}
  \frametitle{\vl{next}-Beweis}
  Zeige, dass $\vl{next}~(\vl{pair}~n~m)$ zu $\vl{pair}~m~(\vl{succ}~m)$ reduziert.
  \pause
  \begin{align*}
    \vl{next}~(\vl{pair}~n~m)
    \onslide<3->{&\betareduce^\past \vl{pair}~(\vl{snd}~(\vl{pair}~n~m))~(\vl{succ}~(\vl{snd}~(\vl{pair}~n~m)))} \\
    \onslide<4->{&\betareduce^\ast \vl{pair}~m~(\vl{succ}~(\vl{snd}~(\vl{pair}~n~m)))} \\
    \onslide<5->{&\betareduce^\ast \vl{pair}~m~(\vl{succ}~m)}
  \end{align*}
  \pause[6]%
  (Informelle Richtlinie für die Klausur:
  die einzigen $β$-Reduktionsschritte, die abgekürzt werden sollten,
  sind solche, die bereits gezeigt wurden~($\betareduce^\ast$),
  sowie solche, bei denen nur mehrere direkt hintereinander stehende $λ$s eingesetzt werden~(z.\,B.~$\betareduce^3$ bei drei~$λ$s).)
\end{frame}

\begin{frame}
  \frametitle{\vl{pred}}
  Verwende \vl{next}, um Vorgängerfunktion \vl{pred} für Church-Zahlen anzugeben.
  \textbf{Hinweis:} $n$-malige Anwendung von \vl{next} auf das Paar $(0,0)$ liefert $(n-1,n)$.
  \pause
  \[\vl{pred} = λ?n.~\vl{fst}~(?n~\vl{next}~(\vl{pair}~c_0~c_0))\]
\end{frame}

\begin{frame}
  \frametitle{$\vl{pred}~c_2$}
  Berechne $\vl{pred}~c_2$ per Beta-Reduktion.
  \pause
  \begin{align*}
    \vl{pred}~c_2
    \onslide<3->{&=^\past (λ?n.~\vl{fst}~(?n~\vl{next}~(\vl{pair}~c_0~c_0)))~c_2} \\
    \onslide<4->{&\betareduce^\past \vl{fst}~(c_2~\vl{next}~(\vl{pair}~c_0~c_0))} \\
    \onslide<5->{&=^\past \vl{fst}~((λ?s.~λ?z.~?s~(?s~?z))~\vl{next}~(\vl{pair}~c_0~c_0))} \\
    \onslide<6->{&\betareduce^2 \vl{fst}~(\vl{next}~(\vl{next}~(\vl{pair}~c_0~c_0)))} \\
    \onslide<7->{&\betareduce^\ast \vl{fst}~(\vl{next}~(\vl{pair}~c_0~(\vl{succ}~c_0)))} \\
    \onslide<8->{&\betareduce^\ast \vl{fst}~(\vl{pair}~(\vl{succ}~c_0)~(\vl{succ}~(\vl{succ}~c_0)))} \\
    \onslide<9->{&\betareduce^\ast \vl{succ}~c_0} \\
    \onslide<10->{&\betareduce^\ast c_1}
  \end{align*}
\end{frame}

\begin{frame}
  \frametitle{\vl{sub}}
  Definiere Substraktionsfunktion \vl{sub}, die zwei Church-Zahlen voneinander abzieht.
  \pause
  \[\vl{sub} = λ?m.~λ?n.~?n~\vl{pred}~?m\]
  \pause
  Was ist die $β$-Normalform von $\vl{sub}~c_2~c_1$?
  \pause
  \begin{align*}
    \vl{sub}~c_2~c_1
    \onslide<5->{&=^\past (λ?m.~λ?n.~?n~\vl{pred}~?m)~c_2~c_1} \\
    \onslide<6->{&\betareduce^2 c_1~\vl{pred}~c_2} \\
    \onslide<7->{&=^\past (λ?s.~λ?z.~?s~?z)~\vl{pred}~c_2} \\
    \onslide<8->{&\betareduce^2 \vl{pred}~c_2} \\
    \onslide<9->{&\betareduce^\ast c_1}
  \end{align*}
\end{frame}

\begin{frame}
  \frametitle{$λ$-Terme und ihre Typen}
  Gegeben sind folgende $λ$-Terme:
  \begin{align*}
    A &= λ?f.~λ?x.~?f~?x \\
    B &= λ?f.~λ?x.~?f~(?f~?x) \\
    C &= λ?f.~(λ?x.~?f~(?x~?x))~(λ?x.~?f~(?x~?x)) \\
    D &= λ?x.~λ?y.~?y~(?x~?y) \\
    E &= λ?z.~?z \\
    F &= D~E = (λ?x.~λ?y.~?y~(?x~?y))~(λ?z.~?z) \onslide<7->{\betareduce^\ast λ?y.~?y~?y}
  \end{align*}
  Trage jeden Term bei allen passenden Typen ein.
  \begin{tabular}{l|l}
    & ist Typ von Termen \\\hline
    $α → α$                       & \onslide<6->{$E$} \\
    $(α → α) → α → α$             & \onslide<2->{$A$}\onslide<3->{, $B$}\onslide<6->{, $E$} \\
    $(α → β) → α → β$             & \onslide<2->{$A$}\onslide<6->{, $E$} \\
    $((α → β) → α) → (α → β) → β$ & \onslide<5->{$D$} \\
    nicht typisierbar             & \onslide<4->{$C$}\onslide<8->{, $F$}
  \end{tabular}
\end{frame}

\begin{frame}
  \frametitle{$λ$-Terme und ihre Typen}
  \begin{align*}
    D &= λ?x.~λ?y.~?y~(?x~?y) \quad &&:: ((α → β) → α) → (α → β) → β \\
    E &= λ?z.~?z \quad &&:: α → α \\
  \end{align*}
  $D~E$ ist nicht typisierbar, denn dazu müssten Parameter- und Argumenttyp übereinstimmen, also:
  \begin{align*}
    α → α &= (α → β) → α \\
    α &= α → β \\
    &= (α → β) → β \\
    &= ((α → β) → β) → β \\
    &=\dots
  \end{align*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{$λ$-Terme und ihre Typen}
  In Haskell gibt es dementsprechend für
  \begin{lstlisting}
    f = (\x -> \y -> y (x y)) (\z -> z)
  \end{lstlisting}
  auch den Fehler:
  \begin{quote}
    cannot construct the infinite type: \lstinline{t ~ t -> t1}
  \end{quote}
\end{frame}

\end{document}
