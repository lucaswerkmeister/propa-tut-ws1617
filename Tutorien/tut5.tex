\documentclass{beamer}
\usepackage{tut}

\def\tuttitle{Lambda-Kalkül, Typprüfung}
\date{2016-11-28/29}

\begin{document}
\normalsize
\normalem

\begin{frame}[plain]
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Church-Zahlen}
  \begin{align*}
    0 &= 0 \\
    1 &= 1 + 0 \\
    2 &= 1 + 1 + 0 \\
    3 &= 1 + 1 + 1 + 0 \\
    \\
    c_0 &= λs.~λz.~z \\
    c_1 &= λs.~λz.~s~z \\
    c_2 &= λs.~λz.~s~s~z \\
    c_3 &= λs.~λz.~s~s~s~z
  \end{align*}
  Die Church-Zahl für $n∈ℕ$ besteht daraus, dass die Nachfolgerfunktion~$s$ $n$~mal auf das Nullelement~$z$ angewendet wird.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Church-Zahlen in Haskell}
  Der Typ einer Church-Zahl in Haskell ist:
  \begin{lstlisting}
    type Church t = (t -> t) -> t -> t
    ----               s        z
  \end{lstlisting}
  Definiere
  \begin{lstlisting}
    int2church :: Integer -> Church t
    church2int :: Church Integer -> Integer
  \end{lstlisting}
  um von und zu gewöhnlichen Zahlen zu konvertieren.
  (\lstinline{church2int} geht ohne Rekursion.)
\end{frame}

\begin{frame}[fragile]
  \frametitle{\lstinline{int2church}}
  \begin{align*}
    c_0 &= λs.~λz.~z \\
    c_n &= λs.~λz.~\underbrace{s~(s~(\ldots~s}_{\text{$n$ mal}}~z))
  \end{align*}
  \begin{lstlisting}
    int2church :: Integer -> Church t
  \end{lstlisting}
  \pause
  \begin{lstlisting}
    int2church 0 = \s z -> z
    int2church n = \s z -> int2church (n-1) s (s z)
    -- oder
    int2church n = \s z -> s (int2church (n-1) s z)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\lstinline{church2int}}
  \begin{lstlisting}
    church2int :: Church Integer -> Integer
  \end{lstlisting}
  \pause
  \begin{lstlisting}
    church2int c = c (1+) 0
  \end{lstlisting}
  Damit ist
  \begin{lstlisting}
    church2int c3
      = (\s z ->  s   ( s   ( s     z)))  (1+)  0
      =          (1+) ((1+) ((1+)   0))
      =           1  +  1  +  1  +  0
      = 3
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Redexe, Auswertungsstrategie}
  Markiere alle Redexe.
  Welcher wird unter Normal(en)reihenfolge, Call-By-Name und Call-By-Value jeweils zuerst reduziert?
  \pause
  \begin{align*}
    t_1 &= (\cul<3->[c1]{λt.}~λf.~f)~\cul<3->[c1]{((\cul<3->[c2]{λy.}~(\cul<3->[c3]{λx.}~x~x)~\cul<3->[c3]{(λx.~x~x)})~\cul<3->[c2]{((\cul<3->[c4]{λx.}~x)~\cul<3->[c4]{(λx.~x)})})}~(λt.~λf.~f)
  \end{align*}
  \pause[4]%
  Normalreihenfolge und Call-By-Name werten \textcolor{c1}{blau} zuerst aus,
  Call-By-Value wertet \textcolor{c4}{rot} zuerst aus.
  \pause
  \begin{align*}
    t_2 &= λy.~(\cul<6->[c1]{λz.}~(\cul<6->[c2]{λx.}~x)~\cul<6->[c2]{(λx.~x)}~z)~\cul<6->[c1]{y}
  \end{align*}
  \pause[7]%
  Normalenreihenfolge wertet \textcolor{c1}{blau} zuerst aus,
  Call-By-Value und Call-By-Name machen nichts
  ($t_2$ ist schon ein Wert).
\end{frame}

\begin{frame}
  \frametitle{Church-Paare}
  Das Paar $(a,b)$ kann im Lambda-Kalkül so dargestellt werden:
  \[λ?f.~?f~a~b\]
  Damit ist der Paar-Konstruktor \vl{pair}:
  \[\vl{pair} = λ?a.~λ?b.~λ?f.~?f~?a~?b\]
  Wie in Haskell sollen Funktionen \vl{fst}, \vl{snd} erstes und zweites Element extrahieren.
  Dabei ist \vl{fst}:
  \[\vl{fst} = λ?p.~?p~(λ?a.~λ?b.~?a)\]
  Definiere \vl{snd}.
  \pause
  \[\vl{snd} = λ?p.~?p~(λ?a.~λ?b.~?b)\]
\end{frame}

\begin{frame}
  \frametitle{Church-Paare}
  Zeige durch Beta-Reduktion mit Call-By-Name:
  \[\vl{fst}~(\vl{pair}~a~b) \betareduce^\ast a\]
  \pause
  \begin{align*}
    \vl{fst}~(\vl{pair}~a~b) &= (λ?p.~?p~(λ?a.~λ?b.~?a))~((λ?a.~λ?b.~λ?f.~?f~?a~?b)~a~b) \\
    \onslide<3->{&\betareduce (λ?a.~λ?b.~λ?f.~?f~?a~?b)~a~b~(λ?a.~λ?b.~?a)} \\
    \onslide<4->{&\betareduce (λ?b.~λ?f.~?f~a~?b)~b~(λ?a.~λ?b.~?a)} \\
    \onslide<5->{&\betareduce (λ?f.~?f~a~b)~(λ?a.~λ?b.~?a)} \\
    \onslide<6->{&\betareduce (λ?a.~λ?b.~?a)~a~b} \\
    \onslide<7->{&\betareduce (λ?b.~a)~b} \\
    \onslide<8->{&\betareduce a}
  \end{align*}
\end{frame}

\begin{frame}
  \frametitle{\vl{next}}
  \vl{next} soll aus Paar $(n,m)$ das Paar $(m, m+1)$ berechnen (alles in Church-Darstellung).
  \pause
  \begin{align*}
    \vl{next} &= λ?p.~\vl{pair}~(\vl{snd}~?p)~(\vl{succ}~(\vl{snd}~?p))
    \intertext{oder:}
    \vl{next} &= λ?p.~(λ?m.~\vl{pair}~?m~(\vl{succ}~?m))~(\vl{snd}~?p)
  \end{align*}
\end{frame}

\begin{frame}
  \frametitle{\vl{next}-Beweis}
  Zeige, dass $\vl{next}~(\vl{pair}~n~m)$ zu $\vl{pair}~m~(\vl{succ}~m)$ reduziert.
  \pause
  \begin{align*}
    \vl{next}~(\vl{pair}~n~m)
    \onslide<3->{&\betareduce^\past \vl{pair}~(\vl{snd}~(\vl{pair}~n~m))~(\vl{succ}~(\vl{snd}~(\vl{pair}~n~m)))} \\
    \onslide<4->{&\betareduce^\ast \vl{pair}~m~(\vl{succ}~(\vl{snd}~(\vl{pair}~n~m)))} \\
    \onslide<5->{&\betareduce^\ast \vl{pair}~m~(\vl{succ}~m)}
  \end{align*}
  \pause[6]%
  (Informelle Richtlinie für die Klausur:
  die einzigen $β$-Reduktionsschritte, die abgekürzt werden sollten,
  sind solche, die bereits gezeigt wurden~($\betareduce^\ast$),
  sowie solche, bei denen nur mehrere direkt hintereinander stehende $λ$s eingesetzt werden~(z.\,B.~$\betareduce^3$ bei drei~$λ$s).)
\end{frame}

\begin{frame}
  \frametitle{\vl{pred}}
  Verwende \vl{next}, um Vorgängerfunktion \vl{pred} für Church-Zahlen anzugeben.
  \textbf{Hinweis:} $n$-malige Anwendung von \vl{next} auf das Paar $(0,0)$ liefert $(n-1,n)$.
  \pause
  \[\vl{pred} = λ?n.~\vl{fst}~(?n~\vl{next}~(\vl{pair}~c_0~c_0))\]
\end{frame}

\begin{frame}
  \frametitle{$\vl{pred}~c_2$}
  Berechne $\vl{pred}~c_2$ per Beta-Reduktion.
  \pause
  \begin{align*}
    \vl{pred}~c_2
    \onslide<3->{&=^\past (λ?n.~\vl{fst}~(?n~\vl{next}~(\vl{pair}~c_0~c_0)))~c_2} \\
    \onslide<4->{&\betareduce^\past \vl{fst}~(c_2~\vl{next}~(\vl{pair}~c_0~c_0))} \\
    \onslide<5->{&=^\past \vl{fst}~((λ?s.~λ?z.~?s~(?s~?z))~\vl{next}~(\vl{pair}~c_0~c_0))} \\
    \onslide<6->{&\betareduce^2 \vl{fst}~(\vl{next}~(\vl{next}~(\vl{pair}~c_0~c_0)))} \\
    \onslide<7->{&\betareduce^\ast \vl{fst}~(\vl{next}~(\vl{pair}~c_0~(\vl{succ}~c_0)))} \\
    \onslide<8->{&\betareduce^\ast \vl{fst}~(\vl{pair}~(\vl{succ}~c_0)~(\vl{succ}~(\vl{succ}~c_0)))} \\
    \onslide<9->{&\betareduce^\ast \vl{succ}~c_0} \\
    \onslide<10->{&\betareduce^\ast c_1}
  \end{align*}
\end{frame}

\end{document}
