\documentclass{beamer}
\usepackage{tut}

\def\tuttitle{Laziness, Typsystem}
\date{2016-11-14/15}

\begin{document}
\normalsize
\normalem

\begin{frame}[plain]
  \titlepage
\end{frame}

\begin{frame}[fragile]
  \frametitle{\lstinline{fibs}}
  Definiere unendliche Liste \lstinline{fibs :: [Integer]} aller Fibonacci-Zahlen:
  \begin{lstlisting}
    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...]
  \end{lstlisting}
  Lässt sich mit \lstinline{zipWith} sehr kompakt definieren.
  \pause
  \begin{lstlisting}
    fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
  \end{lstlisting}
  Alternativ, ohne \lstinline{zipWith}:
  \begin{lstlisting}
    fibs = fibonacci 0 1
      where fibonacci x y = x : fibonacci y (x+y)
  \end{lstlisting}
  \lstinline{zipWith} war ein \emph{Hinweis}, nicht Teil der Aufgabenstellung selbst, daher wäre auch diese Lösung in der Klausur gültig gewesen.
\end{frame}

\begin{frame}[fragile]
  \frametitle{\lstinline{collatz}}
  Die Collatz-Vermutung besagt, dass die Zahlenfolge
  \[a_{n+1} = \begin{cases}\frac{a_n}{2} & \text{falls $a_n$ gerade} \\ 3a_n + 1 & \text{sonst}\end{cases}\]
  für jeden Startwert $a_0 ∈ ℕ$ die 1 erreicht.
  
  Definiere Funktion \lstinline{collatz}, so dass \lstinline{collatz a0} die unendliche Liste aller Folgenglieder berechnet.
  Verwende \lstinline{iterate} mit geeigneter Hilfsfunktion.
  \pause
  \begin{lstlisting}
    collatz a0 = iterate step a0
      where step an
              | even an   = an `div` 2
              | otherwise = 3*an + 1
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\lstinline{num}}
  Definiere Funktion \lstinline{num}, die für Startwert $a_0$ das kleinste $n$ mit $a_n = 1$ bestimmt.
  Testfall: \lstinline{num 4 == 2}, denn $a_0=4,a_1=2,a_2=1$.
  \pause
  \begin{lstlisting}
    num m = length $ takeWhile (/=1) $ collatz m
  \end{lstlisting}
  Oder:
  \begin{lstlisting}
    import Data.List -- for elemIndex
    import Data.Maybe -- for fromJust
    num m = fromJust $ elemIndex 1 $ collatz m
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\lstinline{maxNum}}
  Definiere Funktion \lstinline{maxNum}.
  \lstinline{maxNum a b} soll ein Tupel \lstinline{(m, num m)} liefern, sodass \lstinline{num m} maximal ist für alle $m ∈ [a,b]$.
  \pause
  \begin{lstlisting}
    maxNum a b = foldl1 help $ map (\m -> (m, num m)) [a..b]
      where help (m, n) (m', n')
              | n' > n    = (m', n')
              | otherwise = (m, n)
  \end{lstlisting}
  Oder:
  \begin{lstlisting}
    import Data.List -- for maximumBy
    maxNum a b = maximumBy help $ map (\m -> (m, num m)) [a..b]
      where help (m,n) (m',n') = compare n n'
  \end{lstlisting}
  (\lstinline{help} kann man auch als \lstinline{compare `on` snd} schreiben – \lstinline{on}, aus \lstinline{Data.Function}, ist eine Variante des Verkettungsoperators \lstinline{.} für Funktionen mit zwei Argumenten.)
\end{frame}

\begin{frame}[fragile]
  \frametitle{\lstinline{primepowers}}
  Definiere Funktion \lstinline{primepowers}, die für gegebenen Parameter $n$ die unendliche Liste der ersten $n$ Potenzen aller Primzahlen berechnet, aufsteigend sortiert.
  Bereits vorgegeben sind die unendliche, aufsteigend sortierte Liste \lstinline{primes} aller Primzahlen sowie \lstinline{merge} vom ersten Übungsblatt.
  (Der Potenzoperator in Haskell ist \lstinline{^}.)
  \pause
  \begin{lstlisting}
    primepowers 1 = primes
    primepowers n = merge
      (map (^n) primes)
      (primepowers (n-1))
  \end{lstlisting}
  Oder:
  \begin{lstlisting}
    primepowers n = foldr merge []
      [map (^i) primes | i <- [1..n]]
  \end{lstlisting}
  Aber nicht:
  \begin{lstlisting}
    primepowers n = foldr merge []
      [map (p^) [1..n] | p <- primes]
  \end{lstlisting}
\end{frame}

\end{document}
