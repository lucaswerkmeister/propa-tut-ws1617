\documentclass{beamer}
\usepackage{tut}

\def\tuttitle{Prolog, Unifikation, Cuts, Codes}
\date{2016-12-19/20}

\lstset{language=prolog} % not \prolog because we want to use the ?x trick again

\begin{document}
\normalsize
\normalem

\begin{frame}[plain]
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Unifikation}
  Gegeben ist das Gleichungssystem
  \begin{align*}
    ?X_1 &= ?X_2 \\
    ?X_2 &= ?X_3
  \intertext{sowie die Substitutionen}
    σ_1 &= [?X_1 ⇒ ?X_2, ?X_2 ⇒ ?X_3] \\
    σ_2 &= [?X_2 ⇒ ?X_3] ∘ [?X_1 ⇒ ?X_2] \\
    σ_3 &= [?X_1 ⇒ a, ?X_2 ⇒ a, ?X_3 ⇒ a]\text.
  \end{align*}
  Welche der Substitutionen ist ein Unifikator für das Gleichungssystem,
  und welche ist ein allgemeinster Unifikator dafür?
\end{frame}

\begin{frame}
  \frametitle{Unifikation}
  \begin{align*}
    ?X_1 &= ?X_2 \\
    ?X_2 &= ?X_3 \\
  \intertext{Wende $σ_1 = [?X_1 ⇒ ?X_2, ?X_2 ⇒ ?X_3]$ an…}
    \onslide<2->{
    ?X_2 &= ?X_3 \\
    ?X_3 &= ?X_3}
  \end{align*}
  \onslide<2->{Das Gleichungssystem ist nicht immer erfüllt, $σ_1$ ist also kein Unifikator.}
\end{frame}

\begin{frame}
  \frametitle{Unifikation}
  \begin{align*}
    ?X_1 &= ?X_2 \\
    ?X_2 &= ?X_3 \\
  \intertext{Wende $σ_2 = [?X_2 ⇒ ?X_3] ∘ [?X_1 ⇒ ?X_2]$ an…}
    \onslide<2->{
    ?X_3 &= ?X_3 \\
    ?X_3 &= ?X_3}
  \end{align*}
  \onslide<2->{Das Gleichungssystem ist immer erfüllt, $σ_2$ ist also ein Unifikator.}
\end{frame}

\begin{frame}
  \frametitle{Unifikation}
  \begin{align*}
    ?X_1 &= ?X_2 \\
    ?X_2 &= ?X_3 \\
  \intertext{Wende $σ_3 = [?X_1 ⇒ a, ?X_2 ⇒ a, ?X_3 ⇒ a]$ an…}
    \onslide<2->{
    a &= a \\
    a &= a}
  \end{align*}
  \onslide<2->{Das Gleichungssystem ist immer erfüllt, $σ_3$ ist also ein Unifikator.}
\end{frame}

\begin{frame}
  \frametitle{Unifikation}
  Allgemeinster Unifikator ist \pause $σ_2$, denn dabei wird im Gegensatz zu $σ_3$ das Ergebnis noch variabel gelassen.
  (Tatsächlich ist $σ_3 = [?X_3 ⇒ a] ∘ σ_2$.)
  
  Formaler Beweis: $\unify(\{?X_1=?X_2,?X_2=?X_3\})$ ausführen und feststellen, dass $σ_2$ herauskommt.
\end{frame}

\begin{frame}
  \frametitle{Unifikation}
  Bestimme allgemeinsten Unifikator für
  \begin{align*}
    ?a(?t_1,?a(?X_3,?X_4)) &= ?a(?X_1,?X_2) \\
    ?X_3 &= ?t_2 \\
    ?X_4 &= ?X_1\text.
  \end{align*}
  Dieser soll vollständig ausgerechnet sein, also in der Form
  \[[?X_1 ⇒ …, ?X_2 ⇒ …, ?X_3 ⇒ …, ?X_4 ⇒ …]\text.\]
\end{frame}

\begin{frame}
  \frametitle{Unifikation}
  \begin{align*}
    ?a(?t_1,?a(?X_3,?X_4)) &= ?a(?X_1,?X_2) \\
    ?X_3 &= ?t_2 \\
    ?X_4 &= ?X_1
  \end{align*}
  Variante 1: Unifikator per Intuition ausrechnen und direkt angeben:
  \pause
  \[[?X_1 ⇒ ?t_1, ?X_2 ⇒ ?a(?t_2,?t_1), ?X_3 ⇒ ?t_2, ?X_4 ⇒ ?t_1]\]
\end{frame}

\begin{frame}
  \frametitle{Unifikation}
  Variante 2: $\unify$-Algorithmus.
  \begin{align*}
    &\unify(C) = \\
    &\texttt{if } C == ∅ \texttt{ then } [] \\
    &\texttt{else let } \{θ_l = θ_r\} ∪ C' = C \texttt{ in} \\
    &\texttt{  if } θ_l == θ_r \texttt{ then } \unify(C') \\
    &\texttt{  else if } θ_l == ?Y \land ?Y \not\in \FV(θ_r) \texttt{ then } \unify([?Y ⇒ θ_r]C') ∘ [?Y ⇒ θ_r] \\
    &\texttt{  else if } θ_r == ?Y \land ?Y \not\in \FV(θ_l) \texttt{ then } \unify([?Y ⇒ θ_l]C') ∘ [?Y ⇒ θ_l] \\
    &\texttt{  else if } θ_l == ?f(θ_l^1, …, θ_l^n) \land θ_r == ?f(θ_r^1, …, θ_r^n) \\
    &\texttt{  }\texttt{  then } \unify(C' ∪ \{θ_l^1 = θ_r^1, …, θ_l^n = θ_r^n\}) \\
    &\texttt{  else fail}
  \end{align*}
\end{frame}

% TODO a slide for this?

\begin{frame}
  \frametitle{Unifikation}
  Bestimme allgemeinsten Unifikator für
  \[?a([1,2,3],[3,4],?L) = ?a([?X|\vr{Xs}],[?Y|\vr{Ys}],\vr{L2})\text.\]
  \pause
  \[σ=[?L ⇒ \vr{L2}, ?X ⇒ 1, \vr{Xs} ⇒ [2,3], ?Y ⇒ 3, \vr{Ys} ⇒ [4]]\]
\end{frame}

\begin{frame}
  \frametitle{Reguläre Ausdrücke}
  Reguläre Ausdrücke lassen sich in Prolog in Präfixnotation darstellen:
  \begin{table}
    \begin{tabular}{c|c}
      Ausdruck & Prolog-Term \\\hline
      $a \cdot b \cdot c$ & $•(?a,•(?b,?c))$ \\
      $a^*$ & $*(?a)$ \\
      $ε ∪ b$ & $∪(ε,?b)$ \\
      $a^* ∪ (a \cdot b \cdot c) ∪ (ε∪b)^*$ & $∪(*(?a),∪(•(?a,•(?b,?c)),*(∪(ε,?b))))$
    \end{tabular}
  \end{table}
  Implementiere Prädikat \lstinline{matches(Regexp,S)}, das prüft, ob Zeichenfolge \lstinline{S} durch Ausdruck \lstinline{Regexp} akzeptiert wird.
  Hilfreich sind dabei \lstinline{append(S1,S2,S)}, \lstinline{not} und \lstinline{atom}.
\end{frame}

\begin{frame}
  \frametitle{Reguläre Ausdrücke: $ε$}
  Der Ausdruck $ε$ akzeptiert die leere Zeichenfolge.
  
  \pause
  \texttt{matches($ε$,[]).}
\end{frame}

\begin{frame}
  \frametitle{Reguläre Ausdrücke: Atome}
  Ausdrücke $a,b,c,…$ akzeptieren jeweils die Zeichenfolge „a“, „b“, „c“, ….
  
  \pause
  \lstinline{matches(C,[C]) :- atom(C).}
\end{frame}

\begin{frame}
  \frametitle{Reguläre Ausdrücke: $∪$}
  Ausdrücke $α∪β$ akzeptieren eine Zeichenfolge $s$, falls $s$ durch $α$ oder $β$ akzeptiert wird.
  
  \pause
  \texttt{%
    matches($∪$(A,\_),S) :- matches(A,S).\\
    matches($∪$(\_,B),S) :- matches(B,S).
  }
\end{frame}

\begin{frame}
  \frametitle{Reguläre Ausdrücke: $\cdot$}
  Ausdrücke $α \cdot β$ akzeptieren eine Zeichenfolge $s_1 \cdot s_2$, falls $α$ die Folge $s_1$ und $β$ die Folge $s_2$ akzeptiert.
  
  \pause
  \texttt{matches($•$(A,B),S) :- append(S1,S2,S),\\
    \texttt{ }\texttt{ }matches(A,S1), matches(B,S2).}
\end{frame}

\begin{frame}
  \frametitle{Reguläre Ausdrücke: $*$}
  Ausdrücke $α^*$ akzeptieren
  \begin{itemize}
  \item die leere Zeichenfolge, sowie
  \item Zeichenfolgen $s_1 \cdot s_2$, falls $s_1$ nicht die leere Folge ist, $α$ die Folge $s_1$ akzeptiert und $α^*$ die Folge $s_2$ akzeptiert.
  \end{itemize}
  
  \pause
  \texttt{%
    matches(*(\_),[]).\\ \pause
    matches(*(A),S) :- append(S1,S2,S), \textbf{not}(S1=[]),\\
      \texttt{ }\texttt{ }matches(A,S1), matches(*(A), S2).
  }
\end{frame}

\end{document}
