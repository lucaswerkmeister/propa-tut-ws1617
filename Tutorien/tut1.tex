\documentclass{beamer}
\usepackage{tut}

\def\tuttitle{Haskell-Grundlagen, Listen}
\date{2016-10-28/31}

\begin{document}
\normalsize
\normalem

\begin{frame}[plain]
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Nachtrag zum Im-Browser-Haskell}
  \begin{itemize}
  \item sollte jetzt stabiler sein
  \item am besten Notebooks selbst herunterfahren, wenn sie nicht mehr benötigt werden
  \item insbesondere: wenn eine lange Berechnung nicht zu Ende kommt, nicht einfach das Notebook schließen!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\lstinline{pow1}}
  Schreiben Sie eine rekursive Funktion \lstinline{pow1}, die Basis \lstinline{b} und Exponent \lstinline{e} als Parameter nimmt und $b^e$ naiv über
  \begin{align*}
    b^0 &= 1\\
    b^{e+1} &= b \cdot b^e
  \end{align*}
  berechnet.
  \pause
  \begin{lstlisting}
    pow1 b 0 = 1
    pow1 b e = b * pow1 b (e-1)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\lstinline{pow2}}
  Wesentlich effizienter ist es, bei jedem Rekursionsschritt den Exponenten zu halbieren und die Basis zu quadrieren:
  \begin{align*}
    b^{2e} &= (b^2)^e \\
    b^{2e+1} &= b \cdot (b^2)^e
  \end{align*}
  Schreiben Sie weitere Funktion \lstinline{pow2}, die Potenz auf diese Weise effizienter berechnet.
  Wie viele Aufrufe braucht \lstinline{pow2} im Vergleich zu \lstinline{pow1}?
  \pause
  \begin{lstlisting}
    pow2 b 0 = 1
    pow2 b e
      | even e    = pow2 (b*b) (e `div` 2)
      | otherwise = b * pow2 (b*b) (e `div` 2)
  \end{lstlisting}
  
  \pause
  \lstinline{pow1} läuft in $\Theta(e)$, \lstinline{pow2} in $\Theta(\log e)$.
\end{frame}

\end{document}
